#' Filter Data by Quantile Threshold
#'
#' This function filters a data frame or data.table by retaining rows where the specified variable is 
#' greater than or equal to a given quantile threshold. It supports filtering by the variable's name 
#' or by its index position.
#'
#' @param df A data frame or data.table to filter.
#' @param var_field Character or integer indicating the column to filter by. If character, it should match the column name; 
#' if integer, it should match the column index.
#' @param probs Numeric value between 0 and 1 indicating the quantile threshold for filtering. Rows with values 
#' in `var_field` greater than or equal to this quantile are retained.
#'
#' @return The filtered data frame or data.table containing rows where the specified variable is at or above the specified quantile.
#'
#' @export
filter_ntile <- function(df, var_field, probs){
  # Find index of variable
  var_index <- 0
  if (is.character(var_field)) {
    var_index <- match(var_field, names(df))
  } else {
    var_index <- match(var_field, seq(length(df)))
  }
  if (is.na(var_index))
    stop("var_field not found")
  if (!is.numeric(df[[var_index]]))
    stop("var_field must refer to a numeric mode column")
  
  # Filter df - base R method to allow index matching
  df <- df[which(df[[var_index]] >= stats::quantile(df[[var_index]],
                                                    probs = probs)), ,
           drop = FALSE]
  return(df)
  
}





#' Z-score Standardization
#'
#' This function performs Z-score standardization (also called normalization) on a numeric vector. 
#' It scales the input data so that it has a mean of 0 and a standard deviation of 1.
#'
#' @param x A numeric vector to be standardized. Missing values (NA) will be ignored in the calculation.
#'
#' @return A numeric vector of the same length as `x`, where each value is standardized to have a mean of 0 
#' and a standard deviation of 1. Any missing values (NA) in `x` are preserved.
#'
#' @details The function calculates the mean and standard deviation of the input vector, ignoring any 
#' missing values (`NA`). It then subtracts the mean from each value and divides the result by the standard deviation.
#' 
#' @examples
#' # Example usage
#' x <- c(1, 2, 3, 4, 5)
#' z_standardize(x)
#' 
#' @export
z_standardize <- function(x) {
  mu <- mean(x, na.rm = TRUE)
  sigma <- stats::sd(x, na.rm = TRUE)
  return((x - mu) / sigma)
}





#' Replace Emojis with Descriptive Names
#'
#' Replaces emoji characters in a character vector with their corresponding
#' descriptive names in `:colon_syntax:` (e.g., "ðŸ”¥" becomes ":fire:").
#' Only emojis present in the input are processed to maximize performance.
#'
#' @param text_vec A character vector containing text with emojis to be replaced.
#'
#' @return A character vector of the same length as `text_vec`, where all detected
#' emojis are replaced with their descriptive names in `:colon:` format.
#'
#' @details
#' This function uses the `emoji::emoji_name` dataset for emoji-to-name mapping
#' and `stringi` for high-performance detection and substitution.
#' Only emojis that are actually present in the input are processed, making
#' the function suitable for large text corpora.
#' 
#' @export
replace_emoji_with_name <- function(text_vec) {
  
  if (!requireNamespace("emoji", quietly = TRUE)) {
    stop("Package 'emoji' is required for this function. Please install it.")
  }
  if (!requireNamespace("stringi", quietly = TRUE)) {
    stop("Package 'stringi' is required for this function. Please install it.")
  }
  
  emoji_vec <- emoji::emoji_name
  
  # emoji â†’ :name: mapping
  replacement_map <- setNames(paste0(":", names(emoji_vec), ":"), unname(emoji_vec))
  emoji_chars <- names(replacement_map)
  
  # Only keep emojis that appear in the input
  present <- vapply(emoji_chars, function(e) any(stringi::stri_detect_fixed(text_vec, e)), logical(1))
  
  for (emoji in emoji_chars[present]) {
    text_vec <- stringi::stri_replace_all_fixed(
      str = text_vec,
      pattern = emoji,
      replacement = replacement_map[[emoji]],
      vectorize_all = FALSE
    )
  }
  
  text_vec
}




#' Clean and repair JSON-like strings generated by LLMs
#'
#' This function attempts to sanitize JSON-like character strings returned by large language models (LLMs),
#' preparing them for parsing via `jsonlite::fromJSON()`. It extracts the first substring that resembles
#' a JSON object, replaces single quotes with double quotes (when safe), escapes backslashes,
#' and ensures the string is properly enclosed in curly braces.
#'
#' @param json_strings A character vector of JSON-like strings (often malformed) generated by an LLM.
#'
#' @return A character vector of cleaned strings, formatted to increase the likelihood of successful parsing
#'   with `jsonlite::fromJSON()`.
#'
#' @examples
#' # Example 1: Fix single quotes
#' raw_json <- "{'label':'Test','description':'A test case','lang':'en'}"
#' clean_json_strings(raw_json)
#'
#' # Example 2: Handle backslashes in paths
#' messy_json <- "{'label':'Path','description':'Folder path is C:\\\\Users\\\\','lang':'en'}"
#' clean_json_strings(messy_json)
#'
#' # Example 3: Add missing braces
#' no_braces <- "'label':'Oops','lang':'en'"
#' clean_json_strings(no_braces)
#'
#' @details
#' This function is not guaranteed to fix all malformed JSON but is useful for cleaning common
#' LLM formatting issues. It does not validate the final JSON structureâ€”only prepares it for parsing.
#'
#' @seealso [jsonlite::fromJSON()]
#'
#' @export
clean_json_strings <- function(json_strings) {
  vapply(json_strings, function(x) {
    # Extract JSON-like block
    x <- sub(".*?(\\{.*\\}).*", "\\1", x)
    
    # Trim whitespace
    x <- trimws(x)
    
    # Ensure braces
    if (!startsWith(x, "{")) x <- paste0("{", x)
    if (!endsWith(x, "}")) x <- paste0(x, "}")
    
    # Replace single quotes with double quotes around keys and values
    x <- gsub("(?<=[:{,\\s])'(.*?)'", "\"\\1\"", x, perl = TRUE)
    x <- gsub("^'(.*?)'$", "\"\\1\"", x, perl = TRUE)
    
    # Escape unescaped backslashes (each \ â†’ \\)
    x <- gsub("\\\\", "\\\\\\\\", x)
    
    # Remove newlines
    x <- gsub("\\n", " ", x)
    
    x
  }, character(1))
}

